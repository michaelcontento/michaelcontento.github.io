[{"categories":null,"contents":"Die Tage hatte ich ein lustiges kleines Problem bei dem Versuch ein großes Git Repository nach Azure DevOps zu importieren:\nSehr große Pushs verwenden viele Ressourcen, blockieren oder verlangsamen andere Teile des Diensts. Solche Pushs werden häufig nicht zu normalen Softwareentwicklungsaktivitäten zugeordnet. Jemand hat möglicherweise versehentlich in Buildausgaben oder ein VM-Image eingecheckt, z. B. Aus diesen Gründen und mehr sind Pushs auf 5 GB zu einem Zeitpunkt beschränkt.\n\u0026ndash; Azure DevOps Dokumentation (hervorhebung von mir)\nAlso .. uhm .. naja, das ist nun doof, da mein Repository halt größer ist als 5GB :cry:\n:x: Lösung: Web Import Welche Lösung schlägt Microsoft hier vor? Man soll das Git Repository einfach über ein web import laufen lassen!\nLeider war das keine Option, da das Quellsystem (auf dem das Git Repository primär gehosted ist) für Azure DevOps nicht direkt erreichbar war (Firewall und so) :cry: :cry:\n:white_check_mark: Lösung: Gestückeltes git push Nun, wenn man die Dokumentation aufmerksam liest, dann merkt man das ein einzelnes git push nicht größer sein darf als 5GB. Das komplette Repository kann aber bis auf 250GB anwachsen.\nHa! Hier können wir also ansetzen! Wir schieben unser Repository einfach in kleinen Stücken nach Azure DevOps, bleiben immer unter den 5GB und nach einigen Runden git push haben wir alles drüben.\nMit einem bisschen bash klappt das wie folgt:\n$ # Ensure we\u0026#39;re starting from the master branch $ git checkout master $ # First we need to count the total amount of commits $ TOTAL_COMMITS=$(git log --pretty=oneline | wc -l) $ # How many commits should be in a single chunk? $ COMMITS_PER_CHUNK=50 $ # Push our commits in small chunks $ for CURSOR in $(seq $TOTAL_COMMITS -$COMMITS_PER_CHUNK 0); do \\ git push origin master~$CURSOR:master; \\ done $ # And finally push the missing rest (tags, etc.) $ git push --mirror origin In meinem Fall war es ausreichend das ganze einmal auf dem master Branch laufen zu lassen, da sich das finale git push --mirror um den ganzen fehlenden Rest (tags und andere Branches) gekümmert hat.\n:bell: Warnung :bell:\nDas letzte git push --mirror kann auch in die 5GB Grenze laufen, wenn es viele / große Commits außerhalb von dem master branch gibt! In dem Fall wiederholt man die Schritte in einem anderen Branch bis git push --mirror dann ebenfalls durchläuft.\n","date":"20 Oct, 2022","image":"\n\n\n\n\n\n\n\n\n\u003cimg loading=\"lazy\" decoding=\"async\" src=\"https://www.michaelcontento.de/blog-2022-11.png\" alt=\"\" class=\"w-100 img-fluid rounded\" height=\"\" width=\"\"\u003e\n","permalink":"https://www.michaelcontento.de/blog/2022/10/20/gest%C3%BCckeltes-git-push-nach-azure-devops/","tags":["Git","Azure DevOps","Azure"],"title":"Gestückeltes git-push nach Azure DevOps"},{"categories":null,"contents":":trophy: Credly \u0026hellip; wer? Hast du schon einmal von der Zertifizierungsplattform Credly gehört? Es ist eine Website die ein sehr einfaches Problem löst: Erfassen und Anzeigen von Zertifizierungen auf zuverlässige und vertrauenswürdige Weise.\nWas bedeutet das? Es bedeutet einfach, dass Credly als zentrales Bindeglied zwischen allen Organisationen fungiert, die Zertifizierungen ausstellen (wie Microsoft, GitHub und viele mehr). Damit kann man sehr einfach z.B. meine Person bei Credly besuchen und alle meine Zertifizierungen anschauen. Darüber hinaus kann man die Zertifizierungen noch verifizieren und - jetzt kommt das spannende - all diese Informationen sind in einem definierten JSON-Format verfügbar.\n:light_bulb: Idee zur Automatisierung Cool! Aber warum erzähle ich das?\nEinfach weil ich alle meine Zertifikate auf diesem Blog auflisten und/oder zeigen wollte, ohne sie ständig manuell synchronisieren zu müssen (weil \u0026hellip; naja \u0026hellip; ich bin ein fauler Entwickler :joy:).\n:gear: Architektur Mit der Idee an der Hand schauen wir uns erst einmal die aktuelle Systemlandschaft von diesem Blog an:\n%%{init: {'theme':'neutral'}}%% flowchart TB HugoBuild[[hugo build]] Credly[(Credly)] GitRepo[(Git Repo\nBranch: main)] GitHubPages([GitHub Pages]) GitHubPagesA([GitHub Pages]) GitGhPages[(Git Repo\nBranch: gh-pages)] subgraph d[\"(3) Customer\"] direction TB Visitor -- Visits --\u003e GitHubPagesA; end subgraph c[\"(2) Build\"] direction TB GitRepo -- On every push --\u003e HugoBuild; HugoBuild -- git add --\u003e GitGhPages; GitGhPages -- Deploy --\u003e GitHubPages; end subgraph a[\"(1) Certification\"] direction TB User -- Earn certification --\u003e Organization; Organization -- Report certifications --\u003e Credly; end style a fill:none style c fill:none style d fill:none Wenn wir uns also das obige Diagramm ansehen, dann erkennen wir drei lose gekoppelte Aufgaben / Workflows / Silos:\n(1) Zertifizierungen Ein Benutzer (wie ich) erwirbt Zertifizierungen bei einer Organisation (wie Microsoft) Einmal erworben, wird die Zertifizierung an Credly gepusht (2) Website Dieser Blog wird mit Hugo erstellt und auf GitHub gehostet Jeder Push auf den main Branch löst eine GitHub-Action aus, die wiederum hugo build ausführt und die Build-Ergebnisse in einem dedizierten gh-pages Branch veröffentlicht GitHub Pages erkennt jede Änderung innerhalb von gh-pages und veröffentlicht sie in der \u0026ldquo;GitHub Cloud\u0026rdquo; (3) Endkunden Mein DNS (gehostet bei Gandi übrigens) zeigt auf die \u0026ldquo;GitHub Cloud\u0026rdquo; Benutzer (genauer: ihr Browser) bezieht die endgültige Website aus der \u0026ldquo;GitHub Cloud\u0026rdquo; Das ist alles in Ordnung und ermöglicht es uns auch, ziemlich einfach in alle Dimensionen zu erweitern. Meine Idee ist einen neuen, lose gekoppelten, GitHub Actions-Workflow einzuführen, der regelmäßig alle meine Zertifikate von Credly abruft und die Informationen in Git speichert. Damit würde jede Änderung auf Credly in unserem Git-Repository widergespiegelt werden, was wiederum den existierenden hugo build-Workflow startet. Ziemlich nett, nicht wahr?\nDas endgültige gewünschte Zustandsdiagramm würde also so ​​aussehen:\n%%{init: {'theme':'neutral'}}%% flowchart TB BadgeJson{{Metadata JSON}} BadgeImages{{Badge images}} ActionCredly[[New GitHub Action]] CredlyA[(Credly)] GitRepoA[(Git Repo\nBranch: main)] subgraph b[\"(4) Credly Import\"] direction TB CredlyA -. Fetch data .-\u003e ActionCredly; ActionCredly -- Generates --\u003e BadgeJson; ActionCredly -- Stores --\u003e BadgeImages; BadgeJson -- git add --\u003e GitRepoA; BadgeImages -- git add --\u003e GitRepoA; end style b fill:#c0f1ff %% ---------------------------------------------------- %% CODE FROM ABOVE %% ---------------------------------------------------- HugoBuild[[hugo build]] Credly[(Credly)] GitRepo[(Git Repo\nBranch: main)] GitHubPages([GitHub Pages]) GitHubPagesA([GitHub Pages]) GitGhPages[(Git Repo\nBranch: gh-pages)] subgraph d[\"(3) Customer\"] direction TB Visitor -- Visits --\u003e GitHubPagesA; end subgraph c[\"(2) Build\"] direction TB GitRepo -- On every push --\u003e HugoBuild; HugoBuild -- git add --\u003e GitGhPages; GitGhPages -- Deploy --\u003e GitHubPages; end subgraph a[\"(1) Certification\"] direction TB User -- Earn certification --\u003e Organization; Organization -- Report certifications --\u003e Credly; end style a fill:none style c fill:none style d fill:none Wie man oben sehen kann, haben wir nichts an den bestehenden Workflows / Interaktionen geändert. Wir haben einfach einen ganz neuen Workflow hinzugefügt, der die Credly-Dateien in unser eigenes Repository importiert. Und jede Änderung an unserem Repository löst konstruktionsbedingt ein hugo build der Website aus. :sign_of_the_horns:\n:rocket: Implementierung Aber wie implementieren wir das Ganze? Meine Lösung besteht aus zwei Teilen die, meiner Meinung nach, gut zusammenspielen.\n:one: Daten einsammeln mit Credly2Hugo Diese neue GitHub Action sammelt alle Informationen von Credly. Sie ist sehr einfach zu verwenden, da die meisten Parameter optional sind und daher reicht meist:\n# Add this step in one of your GitHub Workflow files - uses: michaelcontento/credly2hugo-action@v1 with: # The user of whom we want to grab the infos name: michael-contento Das ganze erzeugt nun folgende Dateien:\ndata/CredlyBadges.json, eine Hugo optimierte metadata JSON Datei data/CredlyBadgesRaw.json, enthält das komplette metadata JSON von Credly assets/images/CredlyBadges/*, hier werden die Bilder aller Zertifikate gespeichert Damit haben wir alle Informationen von Credly erfolgreich in unser eigenes Git-Repository importiert und können sie nach Belieben verwenden.\n:sparkles: Hinweis :sparkles:\nSchau einfach in die Workflow-Datei von diesem Blog für ein komplettes Beispiel\nWenn du wissen willst wie Credly2Hugo funktioniert, dann schau einfach den Code auf GitHub. Es ist nichts besonderes, nur etwas curl für den Datenabruf und jq, um die Hugo-optimierte Metadaten-JSON-Datei zu erstellen.\n:two: In Hugo verwenden Jetzt haben wir also alle Informationen in unserem Repository gespeichert - nice! Aber wie greifen wir auf sie zu? Dank Hugo Data Templates ist das so einfach wie:\n// Iterate over our hugo optimized metadata file {{ range .Site.Data.CredlyBadges }} // give the current record a name for readability in the following \u0026lt;img\u0026gt; {{ $credly := . }} // let Hugo grab the image and resize it {{ $image := (resources.Get .LocalImagePath).Resize \u0026#34;150x150\u0026#34; }} // and simply render our bage as plain html image \u0026lt;img src=\u0026#34;{{ $image.RelPermalink }}\u0026#34; width=\u0026#34;{{ $image.Width }}\u0026#34; height=\u0026#34;{{ $image.Height }}\u0026#34; alt=\u0026#34;{{ $credly.Description }}\u0026#34;\u0026gt; {{ end }} Was dann so aussieht:\n:tada: Tada! :tada: :chequered_flag: Fazit Wir haben unsere Abzeichen dynamisch auf unserer Seite gerendert, ohne sie jedes Mal manuell importieren zu müssen sobald wir ein neues Zertifikat bekommen und ohne dynamisches clientseitiges Javascript verwenden zu müssen.\nAlles ist reines Hugo Server Side Rendering :sunglasses:\nUnd alles ist in Code als GitHub Actions automatisiert, alles wird in Git gespeichert und als ganz kleines Goodie bekommen wir auch noch eine \u0026ldquo;Zertifikatshistory\u0026rdquo; gratis dazu :joy:\n","date":"19 Oct, 2022","image":"\n\n\n\n\n\n\n\n\n\u003cimg loading=\"lazy\" decoding=\"async\" src=\"https://www.michaelcontento.de/blog-2022-10.png\" alt=\"\" class=\"w-100 img-fluid rounded\" height=\"\" width=\"\"\u003e\n","permalink":"https://www.michaelcontento.de/blog/2022/10/19/scraping-credly-mit-github-actions/","tags":["github action","credly","microsoft"],"title":"Scraping Credly mit GitHub Actions"},{"categories":null,"contents":"Nach 20 Monaten Sprengnetter und einem Monat Urlaub kann ich nun voller freude verkünden: Ab heute bin ich Teil von Xpirit :sunglasses:\nIch freue mich sehr, diesem Team aus sehr erfahrenen Beratern und Experten für Cloud-Transformation mit Microsoft Azure, dem Aufbau von Hochleistungs-IT-Teams mit DevOps und der Entwicklung von Cloud-native Software beizutreten.\nMit diesem Schritt stehen für mich die Gleise vollends 100% auf Microsoft, C# und Azure. PHP hat mich viele viele Jahre begleitet aber frischer Wind in dem \u0026ldquo;persönlichen Tech-Stack\u0026rdquo; belebt Geist und Seele :angel:\nAchja! Xpirit wächst weiter und bei Interesse einfach mal hier reinschauen.\n","date":"01 Sep, 2022","image":"\n\n\n\n\n\n\n\n\n\u003cimg loading=\"lazy\" decoding=\"async\" src=\"https://www.michaelcontento.de/blog-2022-09.png\" alt=\"\" class=\"w-100 img-fluid rounded\" height=\"\" width=\"\"\u003e\n","permalink":"https://www.michaelcontento.de/blog/2022/09/01/neuer-arbeitgeber-xpirit/","tags":["xpirit","career update"],"title":"Neuer Arbeitgeber? Xpirit!"}]