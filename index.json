[{"categories":null,"contents":"Keep on innovating! Am 25.11.2022 fand der zweite Innovation Day @ Xpirit statt und es war der erste, an dem ich einen eigenen Slot gestarte habe.\nAber was ist der Innovation Day überhaupt? Es ist ein vierteljährliches Treffen, bei dem sich alle Mitglieder von Xpirit physisch treffen und entwickeln, erforschen, spielen und Wissen teilen. Betrachten es als einen Hackathon im Kreise der Familie :smile:\nUm den Tag ein bisschen zu organisieren, haben wir unser eigenes internes Tool XKE (Xebia Knowledge Exchange), wo jeder mit seiner Idee einen neuen Slot starten kann und andere können beitreten. Es ist wirklich so einfach. Such dir ein Thema oder starte ein neues.\nPlayDate - ein kleines Handheld-Spielsystem Zwei Tage vor dem Innovation Day stellte mir mein Kollege Thomas das PlayDate vor und ich war sofort begeistert.\nWie großartig ist dieses winzige Gerät? Ernsthaft.\nKleiner Bildschirm mit 400 x 240 Pixeln, zwei Farben und eine echten physische Kurbel!\nSicher, das sind ziemlich strenge Beschränkungen im Vergleich zu allen anderen Spielsystemen – aber Beschränkungen regen die Kreativität an! Zumindest lese ich das immer im Internet \u0026hellip; :wink:\nMein erster Innovation Day Slot Also war das Feuer entfacht und ich wollte unbedingt etwas für dieses Gerät bauen. Aber mit 2 Tagen war es unmöglich, rechtzeitig ein physisches Gerät zu bestellen.\nAber die Community hinter PlayDate ist ziemlich großartig und der kostenlos nutzbare Simulator ist \u0026hellip; naja \u0026hellip; awesome! Es ist wirklich Plug-and-Play (oder herunterladen und ausführen, um genauer zu sein).\nFür den Nova-Editor gibt es eine Erweiterung, die ebenfalls wunderbar funktioniert. Obwohl ich Nova oder PlayDate noch nie zuvor verwendet habe, waren es nur ein paar Downloads, Mausklicks und alles kompilierte und lief reibungslos.\nAlso haben wir einen Plan: Wir bauen ein einigermaßen unterhaltsames Spiel für die PlayDate-Konsole!\nWas wollen wir eigentlich bauen? Am Innovation Day fanden sich 3 Kollegen, die meine Idee mochten und sich meinem Slot anschließen. Nun mussten wir ein paar Dinge klären:\nDer Simulator muss auf jedem Entwicklercomputer laufen Wir brauchen ein Git-Repository, in dem wir alle arbeiten können Definieren, welches Spiel wir eigentlich bauen wollen Code Code Code Unsere Erfahrung mit den anderen Teilen :beer: Die ersten zwei Punkte der Liste wurden in ~20 Minuten erledigt. Wie ich schon sagte, die Tools sind Plug-and-Play und mit Playlate haben wir eine tolle Projektvorlage gefunden.\nZu definieren, was wir eigentlich bauen wollen, hat etwas länger gedauert. Ich meine, man könnte im Grunde alles auf diesem Gerät bauen! Alleine mit der Kurbel eröffnen sich hundert verschiedene kreative Möglichkeiten! Tausende Ideen!\nAber unsere Zeit war begrenzt. Und wir wollten etwas erschaffen, das so grob 10 Sekunden Freude bereiten kann.\nWarum nicht ein einfaches \u0026amp; bekanntes Spiel klonen und nur eine kleine Twist hinzufügen? Ha! Das ist es!\nAls Spiel haben wir uns für FlappyBird entschieden und wollten die Kurbel einbauen, um „echtes Flattern“ zu simulieren. Man muss also, für einen einzelnen Flügelschlag, einmal hin und her schwingen.\nDas Ergebnis Es ist ein voll funktionsfähiger Klon von FlappyBird Läuft flüssig bei maximaler FPS ohne jegliche Probleme Wir haben Hintergrundmusik sowie Soundeffekte Sprite-Animationen Endlose Level-Generierung Highscore Kollisionserkennung Alles an einem Tag gebaut - ich bin so stolz auf unsere Gruppe und unser kleines Maskottchen :heart:\nWas haben wir gelernt? Das Bauen von Spielen macht Spaß\nPlayDate ist ein sehr schönes / ausgefeiltes Spielsystem\nWir haben Lua als Entwicklungssprache verwendet\nWir haben FFmpeg verwendet, um Audiodateien in das richtige Format zu konvertieren\nUnd wir hatten eine Menge Spaß beim Bauprozess selbst\n","date":"30 Nov, 2022","image":"\n\n\n\n\n\n\n\n\n\u003cimg loading=\"lazy\" decoding=\"async\" src=\"https://www.michaelcontento.de/blog-2022-12.png\" alt=\"\" class=\"w-100 img-fluid rounded\" height=\"\" width=\"\"\u003e\n","permalink":"https://www.michaelcontento.de/blog/2022/11/30/flying-poop-ein-spiel-an-einem-tag/","tags":["PlayDate","Lua","FlappyBird","Gaming"],"title":"Flying Poop - Ein Spiel an einem Tag"},{"categories":null,"contents":"Die Tage hatte ich ein lustiges kleines Problem bei dem Versuch ein großes Git Repository nach Azure DevOps zu importieren:\nSehr große Pushs verwenden viele Ressourcen, blockieren oder verlangsamen andere Teile des Diensts. Solche Pushs werden häufig nicht zu normalen Softwareentwicklungsaktivitäten zugeordnet. Jemand hat möglicherweise versehentlich in Buildausgaben oder ein VM-Image eingecheckt, z. B. Aus diesen Gründen und mehr sind Pushs auf 5 GB zu einem Zeitpunkt beschränkt.\n\u0026ndash; Azure DevOps Dokumentation (hervorhebung von mir)\nAlso .. uhm .. naja, das ist nun doof, da mein Repository halt größer ist als 5GB :cry:\n:x: Lösung: Web Import Welche Lösung schlägt Microsoft hier vor? Man soll das Git Repository einfach über ein web import laufen lassen!\nLeider war das keine Option, da das Quellsystem (auf dem das Git Repository primär gehosted ist) für Azure DevOps nicht direkt erreichbar war (Firewall und so) :cry: :cry:\n:white_check_mark: Lösung: Gestückeltes git push Nun, wenn man die Dokumentation aufmerksam liest, dann merkt man das ein einzelnes git push nicht größer sein darf als 5GB. Das komplette Repository kann aber bis auf 250GB anwachsen.\nHa! Hier können wir also ansetzen! Wir schieben unser Repository einfach in kleinen Stücken nach Azure DevOps, bleiben immer unter den 5GB und nach einigen Runden git push haben wir alles drüben.\nMit einem bisschen bash klappt das wie folgt:\n$ # Ensure we\u0026#39;re starting from the master branch $ git checkout master $ # First we need to count the total amount of commits $ TOTAL_COMMITS=$(git log --pretty=oneline | wc -l) $ # How many commits should be in a single chunk? $ COMMITS_PER_CHUNK=50 $ # Push our commits in small chunks $ for CURSOR in $(seq $TOTAL_COMMITS -$COMMITS_PER_CHUNK 0); do \\ git push origin master~$CURSOR:master; \\ done $ # And finally push the missing rest (tags, etc.) $ git push --mirror origin In meinem Fall war es ausreichend das ganze einmal auf dem master Branch laufen zu lassen, da sich das finale git push --mirror um den ganzen fehlenden Rest (tags und andere Branches) gekümmert hat.\n:bell: Warnung :bell:\nDas letzte git push --mirror kann auch in die 5GB Grenze laufen, wenn es viele / große Commits außerhalb von dem master branch gibt! In dem Fall wiederholt man die Schritte in einem anderen Branch bis git push --mirror dann ebenfalls durchläuft.\n","date":"20 Oct, 2022","image":"\n\n\n\n\n\n\n\n\n\u003cimg loading=\"lazy\" decoding=\"async\" src=\"https://www.michaelcontento.de/blog-2022-11.png\" alt=\"\" class=\"w-100 img-fluid rounded\" height=\"\" width=\"\"\u003e\n","permalink":"https://www.michaelcontento.de/blog/2022/10/20/gest%C3%BCckeltes-git-push-nach-azure-devops/","tags":["Git","Azure DevOps","Azure"],"title":"Gestückeltes git-push nach Azure DevOps"},{"categories":null,"contents":":trophy: Credly \u0026hellip; wer? Hast du schon einmal von der Zertifizierungsplattform Credly gehört? Es ist eine Website die ein sehr einfaches Problem löst: Erfassen und Anzeigen von Zertifizierungen auf zuverlässige und vertrauenswürdige Weise.\nWas bedeutet das? Es bedeutet einfach, dass Credly als zentrales Bindeglied zwischen allen Organisationen fungiert, die Zertifizierungen ausstellen (wie Microsoft, GitHub und viele mehr). Damit kann man sehr einfach z.B. meine Person bei Credly besuchen und alle meine Zertifizierungen anschauen. Darüber hinaus kann man die Zertifizierungen noch verifizieren und - jetzt kommt das spannende - all diese Informationen sind in einem definierten JSON-Format verfügbar.\n:light_bulb: Idee zur Automatisierung Cool! Aber warum erzähle ich das?\nEinfach weil ich alle meine Zertifikate auf diesem Blog auflisten und/oder zeigen wollte, ohne sie ständig manuell synchronisieren zu müssen (weil \u0026hellip; naja \u0026hellip; ich bin ein fauler Entwickler :joy:).\n:gear: Architektur Mit der Idee an der Hand schauen wir uns erst einmal die aktuelle Systemlandschaft von diesem Blog an:\n%%{init: {'theme':'neutral'}}%% flowchart TB HugoBuild[[hugo build]] Credly[(Credly)] GitRepo[(Git Repo\nBranch: main)] GitHubPages([GitHub Pages]) GitHubPagesA([GitHub Pages]) GitGhPages[(Git Repo\nBranch: gh-pages)] subgraph d[\"(3) Customer\"] direction TB Visitor -- Visits --\u003e GitHubPagesA; end subgraph c[\"(2) Build\"] direction TB GitRepo -- On every push --\u003e HugoBuild; HugoBuild -- git add --\u003e GitGhPages; GitGhPages -- Deploy --\u003e GitHubPages; end subgraph a[\"(1) Certification\"] direction TB User -- Earn certification --\u003e Organization; Organization -- Report certifications --\u003e Credly; end style a fill:none style c fill:none style d fill:none Wenn wir uns also das obige Diagramm ansehen, dann erkennen wir drei lose gekoppelte Aufgaben / Workflows / Silos:\n(1) Zertifizierungen Ein Benutzer (wie ich) erwirbt Zertifizierungen bei einer Organisation (wie Microsoft) Einmal erworben, wird die Zertifizierung an Credly gepusht (2) Website Dieser Blog wird mit Hugo erstellt und auf GitHub gehostet Jeder Push auf den main Branch löst eine GitHub-Action aus, die wiederum hugo build ausführt und die Build-Ergebnisse in einem dedizierten gh-pages Branch veröffentlicht GitHub Pages erkennt jede Änderung innerhalb von gh-pages und veröffentlicht sie in der \u0026ldquo;GitHub Cloud\u0026rdquo; (3) Endkunden Mein DNS (gehostet bei Gandi übrigens) zeigt auf die \u0026ldquo;GitHub Cloud\u0026rdquo; Benutzer (genauer: ihr Browser) bezieht die endgültige Website aus der \u0026ldquo;GitHub Cloud\u0026rdquo; Das ist alles in Ordnung und ermöglicht es uns auch, ziemlich einfach in alle Dimensionen zu erweitern. Meine Idee ist einen neuen, lose gekoppelten, GitHub Actions-Workflow einzuführen, der regelmäßig alle meine Zertifikate von Credly abruft und die Informationen in Git speichert. Damit würde jede Änderung auf Credly in unserem Git-Repository widergespiegelt werden, was wiederum den existierenden hugo build-Workflow startet. Ziemlich nett, nicht wahr?\nDas endgültige gewünschte Zustandsdiagramm würde also so ​​aussehen:\n%%{init: {'theme':'neutral'}}%% flowchart TB BadgeJson{{Metadata JSON}} BadgeImages{{Badge images}} ActionCredly[[New GitHub Action]] CredlyA[(Credly)] GitRepoA[(Git Repo\nBranch: main)] subgraph b[\"(4) Credly Import\"] direction TB CredlyA -. Fetch data .-\u003e ActionCredly; ActionCredly -- Generates --\u003e BadgeJson; ActionCredly -- Stores --\u003e BadgeImages; BadgeJson -- git add --\u003e GitRepoA; BadgeImages -- git add --\u003e GitRepoA; end style b fill:#c0f1ff %% ---------------------------------------------------- %% CODE FROM ABOVE %% ---------------------------------------------------- HugoBuild[[hugo build]] Credly[(Credly)] GitRepo[(Git Repo\nBranch: main)] GitHubPages([GitHub Pages]) GitHubPagesA([GitHub Pages]) GitGhPages[(Git Repo\nBranch: gh-pages)] subgraph d[\"(3) Customer\"] direction TB Visitor -- Visits --\u003e GitHubPagesA; end subgraph c[\"(2) Build\"] direction TB GitRepo -- On every push --\u003e HugoBuild; HugoBuild -- git add --\u003e GitGhPages; GitGhPages -- Deploy --\u003e GitHubPages; end subgraph a[\"(1) Certification\"] direction TB User -- Earn certification --\u003e Organization; Organization -- Report certifications --\u003e Credly; end style a fill:none style c fill:none style d fill:none Wie man oben sehen kann, haben wir nichts an den bestehenden Workflows / Interaktionen geändert. Wir haben einfach einen ganz neuen Workflow hinzugefügt, der die Credly-Dateien in unser eigenes Repository importiert. Und jede Änderung an unserem Repository löst konstruktionsbedingt ein hugo build der Website aus. :sign_of_the_horns:\n:rocket: Implementierung Aber wie implementieren wir das Ganze? Meine Lösung besteht aus zwei Teilen die, meiner Meinung nach, gut zusammenspielen.\n:one: Daten einsammeln mit Credly2Hugo Diese neue GitHub Action sammelt alle Informationen von Credly. Sie ist sehr einfach zu verwenden, da die meisten Parameter optional sind und daher reicht meist:\n# Add this step in one of your GitHub Workflow files - uses: michaelcontento/credly2hugo-action@v1 with: # The user of whom we want to grab the infos name: michael-contento Das ganze erzeugt nun folgende Dateien:\ndata/CredlyBadges.json, eine Hugo optimierte metadata JSON Datei data/CredlyBadgesRaw.json, enthält das komplette metadata JSON von Credly assets/images/CredlyBadges/*, hier werden die Bilder aller Zertifikate gespeichert Damit haben wir alle Informationen von Credly erfolgreich in unser eigenes Git-Repository importiert und können sie nach Belieben verwenden.\n:sparkles: Hinweis :sparkles:\nSchau einfach in die Workflow-Datei von diesem Blog für ein komplettes Beispiel\nWenn du wissen willst wie Credly2Hugo funktioniert, dann schau einfach den Code auf GitHub. Es ist nichts besonderes, nur etwas curl für den Datenabruf und jq, um die Hugo-optimierte Metadaten-JSON-Datei zu erstellen.\n:two: In Hugo verwenden Jetzt haben wir also alle Informationen in unserem Repository gespeichert - nice! Aber wie greifen wir auf sie zu? Dank Hugo Data Templates ist das so einfach wie:\n// Iterate over our hugo optimized metadata file {{ range .Site.Data.CredlyBadges }} // give the current record a name for readability in the following \u0026lt;img\u0026gt; {{ $credly := . }} // let Hugo grab the image and resize it {{ $image := (resources.Get .LocalImagePath).Resize \u0026#34;150x150\u0026#34; }} // and simply render our bage as plain html image \u0026lt;img src=\u0026#34;{{ $image.RelPermalink }}\u0026#34; width=\u0026#34;{{ $image.Width }}\u0026#34; height=\u0026#34;{{ $image.Height }}\u0026#34; alt=\u0026#34;{{ $credly.Description }}\u0026#34;\u0026gt; {{ end }} Was dann so aussieht:\n:tada: Tada! :tada: :chequered_flag: Fazit Wir haben unsere Abzeichen dynamisch auf unserer Seite gerendert, ohne sie jedes Mal manuell importieren zu müssen sobald wir ein neues Zertifikat bekommen und ohne dynamisches clientseitiges Javascript verwenden zu müssen.\nAlles ist reines Hugo Server Side Rendering :sunglasses:\nUnd alles ist in Code als GitHub Actions automatisiert, alles wird in Git gespeichert und als ganz kleines Goodie bekommen wir auch noch eine \u0026ldquo;Zertifikatshistory\u0026rdquo; gratis dazu :joy:\n","date":"19 Oct, 2022","image":"\n\n\n\n\n\n\n\n\n\u003cimg loading=\"lazy\" decoding=\"async\" src=\"https://www.michaelcontento.de/blog-2022-10.png\" alt=\"\" class=\"w-100 img-fluid rounded\" height=\"\" width=\"\"\u003e\n","permalink":"https://www.michaelcontento.de/blog/2022/10/19/scraping-credly-mit-github-actions/","tags":["github action","credly","microsoft"],"title":"Scraping Credly mit GitHub Actions"},{"categories":null,"contents":"Nach 20 Monaten Sprengnetter und einem Monat Urlaub kann ich nun voller freude verkünden: Ab heute bin ich Teil von Xpirit :sunglasses:\nIch freue mich sehr, diesem Team aus sehr erfahrenen Beratern und Experten für Cloud-Transformation mit Microsoft Azure, dem Aufbau von Hochleistungs-IT-Teams mit DevOps und der Entwicklung von Cloud-native Software beizutreten.\nMit diesem Schritt stehen für mich die Gleise vollends 100% auf Microsoft, C# und Azure. PHP hat mich viele viele Jahre begleitet aber frischer Wind in dem \u0026ldquo;persönlichen Tech-Stack\u0026rdquo; belebt Geist und Seele :angel:\nAchja! Xpirit wächst weiter und bei Interesse einfach mal hier reinschauen.\n","date":"01 Sep, 2022","image":"\n\n\n\n\n\n\n\n\n\u003cimg loading=\"lazy\" decoding=\"async\" src=\"https://www.michaelcontento.de/blog-2022-09.png\" alt=\"\" class=\"w-100 img-fluid rounded\" height=\"\" width=\"\"\u003e\n","permalink":"https://www.michaelcontento.de/blog/2022/09/01/neuer-arbeitgeber-xpirit/","tags":["xpirit","career update"],"title":"Neuer Arbeitgeber? Xpirit!"}]